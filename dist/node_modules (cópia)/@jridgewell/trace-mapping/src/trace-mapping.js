"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraceMap = exports.AnyMap = exports.encodedMap = exports.decodedMap = exports.presortedDecodedMap = exports.sourceContentFor = exports.eachMapping = exports.generatedPositionFor = exports.originalPositionFor = exports.traceSegment = exports.decodedMappings = exports.encodedMappings = exports.GREATEST_LOWER_BOUND = exports.LEAST_UPPER_BOUND = void 0;
const sourcemap_codec_1 = require("@jridgewell/sourcemap-codec");
const resolve_1 = require("./resolve");
const strip_filename_1 = require("./strip-filename");
const sort_1 = require("./sort");
const by_source_1 = require("./by-source");
const binary_search_1 = require("./binary-search");
const sourcemap_segment_1 = require("./sourcemap-segment");
const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
exports.LEAST_UPPER_BOUND = -1;
exports.GREATEST_LOWER_BOUND = 1;
var any_map_1 = require("./any-map");
Object.defineProperty(exports, "AnyMap", { enumerable: true, get: function () { return any_map_1.AnyMap; } });
class TraceMap {
    constructor(map, mapUrl) {
        this._decodedMemo = (0, binary_search_1.memoizedState)();
        this._bySources = undefined;
        this._bySourceMemos = undefined;
        const isString = typeof map === 'string';
        if (!isString && map._decodedMemo)
            return map;
        const parsed = (isString ? JSON.parse(map) : map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names;
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        const from = (0, resolve_1.default)(sourceRoot || '', (0, strip_filename_1.default)(mapUrl));
        this.resolvedSources = sources.map((s) => (0, resolve_1.default)(s || '', from));
        const { mappings } = parsed;
        if (typeof mappings === 'string') {
            this._encoded = mappings;
            this._decoded = undefined;
        }
        else {
            this._encoded = undefined;
            this._decoded = (0, sort_1.default)(mappings, isString);
        }
    }
}
exports.TraceMap = TraceMap;
(() => {
    exports.encodedMappings = (map) => {
        var _a;
        return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = (0, sourcemap_codec_1.encode)(map._decoded)));
    };
    exports.decodedMappings = (map) => {
        return (map._decoded || (map._decoded = (0, sourcemap_codec_1.decode)(map._encoded)));
    };
    exports.traceSegment = (map, line, column) => {
        const decoded = (0, exports.decodedMappings)(map);
        if (line >= decoded.length)
            return null;
        return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, exports.GREATEST_LOWER_BOUND);
    };
    exports.originalPositionFor = (map, { line, column, bias }) => {
        line--;
        if (line < 0)
            throw new Error(LINE_GTR_ZERO);
        if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
        const decoded = (0, exports.decodedMappings)(map);
        if (line >= decoded.length)
            return OMapping(null, null, null, null);
        const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || exports.GREATEST_LOWER_BOUND);
        if (segment == null)
            return OMapping(null, null, null, null);
        if (segment.length == 1)
            return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[sourcemap_segment_1.SOURCES_INDEX]], segment[sourcemap_segment_1.SOURCE_LINE] + 1, segment[sourcemap_segment_1.SOURCE_COLUMN], segment.length === 5 ? names[segment[sourcemap_segment_1.NAMES_INDEX]] : null);
    };
    exports.generatedPositionFor = (map, { source, line, column, bias }) => {
        line--;
        if (line < 0)
            throw new Error(LINE_GTR_ZERO);
        if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex = sources.indexOf(source);
        if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
        if (sourceIndex === -1)
            return GMapping(null, null);
        const generated = (map._bySources || (map._bySources = (0, by_source_1.default)((0, exports.decodedMappings)(map), (map._bySourceMemos = sources.map(binary_search_1.memoizedState)))));
        const memos = map._bySourceMemos;
        const segments = generated[sourceIndex][line];
        if (segments == null)
            return GMapping(null, null);
        const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || exports.GREATEST_LOWER_BOUND);
        if (segment == null)
            return GMapping(null, null);
        return GMapping(segment[sourcemap_segment_1.REV_GENERATED_LINE] + 1, segment[sourcemap_segment_1.REV_GENERATED_COLUMN]);
    };
    exports.eachMapping = (map, cb) => {
        const decoded = (0, exports.decodedMappings)(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generatedLine = i + 1;
                const generatedColumn = seg[0];
                let source = null;
                let originalLine = null;
                let originalColumn = null;
                let name = null;
                if (seg.length !== 1) {
                    source = resolvedSources[seg[1]];
                    originalLine = seg[2] + 1;
                    originalColumn = seg[3];
                }
                if (seg.length === 5)
                    name = names[seg[4]];
                cb({
                    generatedLine,
                    generatedColumn,
                    source,
                    originalLine,
                    originalColumn,
                    name,
                });
            }
        }
    };
    exports.sourceContentFor = (map, source) => {
        const { sources, resolvedSources, sourcesContent } = map;
        if (sourcesContent == null)
            return null;
        let index = sources.indexOf(source);
        if (index === -1)
            index = resolvedSources.indexOf(source);
        return index === -1 ? null : sourcesContent[index];
    };
    exports.presortedDecodedMap = (map, mapUrl) => {
        const clone = Object.assign({}, map);
        clone.mappings = [];
        const tracer = new TraceMap(clone, mapUrl);
        tracer._decoded = map.mappings;
        return tracer;
    };
    exports.decodedMap = (map) => {
        return {
            version: 3,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings: (0, exports.decodedMappings)(map),
        };
    };
    exports.encodedMap = (map) => {
        return {
            version: 3,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings: (0, exports.encodedMappings)(map),
        };
    };
})();
function OMapping(source, line, column, name) {
    return { source, line, column, name };
}
function GMapping(line, column) {
    return { line, column };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
    let index = (0, binary_search_1.memoizedBinarySearch)(segments, column, memo, line);
    if (binary_search_1.found) {
        index = (bias === exports.LEAST_UPPER_BOUND ? binary_search_1.upperBound : binary_search_1.lowerBound)(segments, column, index);
    }
    else if (bias === exports.LEAST_UPPER_BOUND)
        index++;
    if (index === -1 || index === segments.length)
        return null;
    return segments[index];
}
//# sourceMappingURL=trace-mapping.js.map