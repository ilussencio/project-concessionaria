"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnyMap = void 0;
const trace_mapping_1 = require("./trace-mapping");
const sourcemap_segment_1 = require("./sourcemap-segment");
exports.AnyMap = function (map, mapUrl) {
    const parsed = typeof map === 'string' ? JSON.parse(map) : map;
    if (!('sections' in parsed))
        return new trace_mapping_1.TraceMap(parsed, mapUrl);
    const mappings = [];
    const sources = [];
    const sourcesContent = [];
    const names = [];
    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);
    const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
    };
    return (0, trace_mapping_1.presortedDecodedMap)(joined);
};
function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
    const { sections } = input;
    for (let i = 0; i < sections.length; i++) {
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
                sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            }
            else if (sl < stopLine) {
                sc = columnOffset + nextOffset.column;
            }
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
    }
}
function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {
    if ('sections' in input)
        return recurse(...arguments);
    const map = new trace_mapping_1.TraceMap(input, mapUrl);
    const sourcesOffset = sources.length;
    const namesOffset = names.length;
    const decoded = (0, trace_mapping_1.decodedMappings)(map);
    const { resolvedSources, sourcesContent: contents } = map;
    append(sources, resolvedSources);
    append(names, map.names);
    if (contents)
        append(sourcesContent, contents);
    else
        for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
    for (let i = 0; i < decoded.length; i++) {
        const lineI = lineOffset + i;
        if (lineI > stopLine)
            return;
        const out = getLine(mappings, lineI);
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[sourcemap_segment_1.COLUMN];
            if (lineI === stopLine && column >= stopColumn)
                return;
            if (seg.length === 1) {
                out.push([column]);
                continue;
            }
            const sourcesIndex = sourcesOffset + seg[sourcemap_segment_1.SOURCES_INDEX];
            const sourceLine = seg[sourcemap_segment_1.SOURCE_LINE];
            const sourceColumn = seg[sourcemap_segment_1.SOURCE_COLUMN];
            out.push(seg.length === 4
                ? [column, sourcesIndex, sourceLine, sourceColumn]
                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[sourcemap_segment_1.NAMES_INDEX]]);
        }
    }
}
function append(arr, other) {
    for (let i = 0; i < other.length; i++)
        arr.push(other[i]);
}
function getLine(arr, index) {
    for (let i = arr.length; i <= index; i++)
        arr[i] = [];
    return arr[index];
}
//# sourceMappingURL=any-map.js.map