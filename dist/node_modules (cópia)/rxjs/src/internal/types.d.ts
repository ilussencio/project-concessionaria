/// <reference lib="esnext.asynciterable" />
import { Observable } from './Observable';
import { Subscription } from './Subscription';
declare global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
export interface UnaryFunction<T, R> {
    (source: T): R;
}
export interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {
}
export declare type FactoryOrValue<T> = T | (() => T);
export interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {
}
export interface Timestamp<T> {
    value: T;
    timestamp: number;
}
export interface TimeInterval<T> {
    value: T;
    interval: number;
}
export interface Unsubscribable {
    unsubscribe(): void;
}
export declare type TeardownLogic = Subscription | Unsubscribable | (() => void) | void;
export interface SubscriptionLike extends Unsubscribable {
    unsubscribe(): void;
    readonly closed: boolean;
}
export declare type SubscribableOrPromise<T> = Subscribable<T> | Subscribable<never> | PromiseLike<T> | InteropObservable<T>;
export interface Subscribable<T> {
    subscribe(observer: Partial<Observer<T>>): Unsubscribable;
}
export declare type ObservableInput<T> = Observable<T> | InteropObservable<T> | AsyncIterable<T> | PromiseLike<T> | ArrayLike<T> | Iterable<T> | ReadableStreamLike<T>;
export declare type ObservableLike<T> = InteropObservable<T>;
export interface InteropObservable<T> {
    [Symbol.observable]: () => Subscribable<T>;
}
export interface NextNotification<T> {
    kind: 'N';
    value: T;
}
export interface ErrorNotification {
    kind: 'E';
    error: any;
}
export interface CompleteNotification {
    kind: 'C';
}
export declare type ObservableNotification<T> = NextNotification<T> | ErrorNotification | CompleteNotification;
export interface NextObserver<T> {
    closed?: boolean;
    next: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
export interface ErrorObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error: (err: any) => void;
    complete?: () => void;
}
export interface CompletionObserver<T> {
    closed?: boolean;
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete: () => void;
}
export declare type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;
export interface Observer<T> {
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
export interface SubjectLike<T> extends Observer<T>, Subscribable<T> {
}
export interface SchedulerLike extends TimestampProvider {
    schedule<T>(work: (this: SchedulerAction<T>, state: T) => void, delay: number, state: T): Subscription;
    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number, state?: T): Subscription;
    schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
}
export interface SchedulerAction<T> extends Subscription {
    schedule(state?: T, delay?: number): Subscription;
}
export interface TimestampProvider {
    now(): number;
}
export declare type ObservedValueOf<O> = O extends ObservableInput<infer T> ? T : never;
export declare type ObservedValueUnionFromArray<X> = X extends Array<ObservableInput<infer T>> ? T : never;
export declare type ObservedValuesFromArray<X> = ObservedValueUnionFromArray<X>;
export declare type ObservedValueTupleFromArray<X> = {
    [K in keyof X]: ObservedValueOf<X[K]>;
};
export declare type ObservableInputTuple<T> = {
    [K in keyof T]: ObservableInput<T[K]>;
};
export declare type Cons<X, Y extends readonly any[]> = ((arg: X, ...rest: Y) => any) extends (...args: infer U) => any ? U : never;
export declare type Head<X extends readonly any[]> = ((...args: X) => any) extends (arg: infer U, ...rest: any[]) => any ? U : never;
export declare type Tail<X extends readonly any[]> = ((...args: X) => any) extends (arg: any, ...rest: infer U) => any ? U : never;
export declare type ValueFromArray<A extends readonly unknown[]> = A extends Array<infer T> ? T : never;
export declare type ValueFromNotification<T> = T extends {
    kind: 'N' | 'E' | 'C';
} ? T extends NextNotification<any> ? T extends {
    value: infer V;
} ? V : undefined : never : never;
export declare type Falsy = null | undefined | false | 0 | -0 | 0n | '';
export declare type TruthyTypesOf<T> = T extends Falsy ? never : T;
interface ReadableStreamDefaultReaderLike<T> {
    read(): PromiseLike<{
        done: false;
        value: T;
    } | {
        done: true;
        value?: undefined;
    }>;
    releaseLock(): void;
}
export interface ReadableStreamLike<T> {
    getReader(): ReadableStreamDefaultReaderLike<T>;
}
export interface Connectable<T> extends Observable<T> {
    connect(): Subscription;
}
export {};
